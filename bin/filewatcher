#!/usr/bin/env ruby
require 'rubygems'
require File.expand_path('../lib/filewatcher.rb', File.dirname(__FILE__))
require 'trollop'
require 'pathname'
require 'thread'

options = Trollop.options do
  version "filewatcher, version #{FileWatcher::VERSION} by Thomas Flemming 2016"
  banner <<-EOS
Filewatcher scans the filesystem and executes shell commands when files changes.

Usage:
   filewatcher [--restart] '<filenames or patterns>' '<shell command>'
Where
   filename: filename(s) to scan.
   shell command: shell command to execute when file changes on disk.

Examples:
   filewatcher "myfile" "echo 'myfile has changed'"
   filewatcher '*.rb' 'ruby $FILENAME'
   filewatcher '**/*.rb' 'ruby $FILENAME' # Watch subdirectories

Other available environment variables are BASENAME, ABSOLUTE_FILENAME,
RELATIVE_FILENAME, EVENT and DIRNAME.

Options:
EOS

  opt :immediate, 'Immediately execute a command',
      short: 'I', type: :boolean, default: false
  opt :daemon, 'Run in the background as system daemon',
      short: 'D', type: :boolean, default: false
  opt :restart, 'Restart process when filesystem is updated',
      short: 'r', type: :boolean, default: false
  opt :list, 'Print name of files being watched'
  opt :exec, 'Execute file as a script when file is updated',
      short: 'e', type: :boolean, default: false
  opt :include, 'Include files',
      type: :string, default: '*'
  opt :exclude, 'Exclude file(s) matching',
      type: :string, default: ''
  opt :interval, 'Interval to scan filesystem.',
      short: 'i', type: :float, default: 0.5
  opt :spinner, 'Show an ascii spinner',
      short: 's', type: :boolean, default: false
end

Trollop.die Trollop.educate if ARGV.size.zero?

files = []
ARGV[0...-1].each do |a|
  files << a
end

files << ARGV[0] if ARGV.length == 1

def split_files_void_escaped_whitespace(files)
  splitted_filenames = []
  files.each do |name|
    name = name.gsub(/\\\s/, '_ESCAPED_WHITESPACE_')
    splitted_filenames << name.split(/\s/)
  end
  files = splitted_filenames.flatten.uniq
  splitted_filenames = []
  files.each do |name|
    splitted_filenames << name.gsub('_ESCAPED_WHITESPACE_', '\ ')
  end
  splitted_filenames
end

files = split_files_void_escaped_whitespace(files)
child_pid = nil

def restart(child_pid, env, cmd)
  Process.kill(9, child_pid)
  Process.wait(child_pid)
rescue Errno::ESRCH
  # already killed
ensure
  Process.spawn(env, cmd)
end

if options[:exclude] != ''
  options[:exclude] = split_files_void_escaped_whitespace(
    options[:exclude].split(' ')
  )
end

begin
  fw = FileWatcher.new(files, options)

  if options[:list]
    puts 'Watching:'
    fw.last_found_filenames.each do |filename|
      puts " #{filename}"
    end
  end

  Process.daemon(true, true) if options[:daemon]

  runners = {
    python: %w(py),
    node: %w(js),
    ruby: %w(rb),
    perl: %w(pl),
    awk: %w(awk),
    php: %w(php phtml php4 php3 php5 phps)
  }

  fw.watch(options[:interval]) do |filename, event|
    cmd = nil
    if options[:exec] && File.exist?(filename)
      ext = File.extname(filename).delete('.')
      runner = runners.find { |_cmd, exts| exts.include? ext }
      cmd = "env #{runner.first} #{filename}" if runner
    elsif ARGV.length > 1
      cmd = ARGV[-1]
    end

    if cmd
      path = Pathname.new(filename)
      env = {
        'FILENAME' => filename,
        'BASENAME' => path.basename.to_s,
        'FILEDIR' => path.parent.realpath.to_s, # Deprecated
        'FSEVENT' => event.to_s, # Deprecated,
        'EVENT' => event.to_s,
        'DIRNAME' => path.parent.realpath.to_s,
        'ABSOLUTE_FILENAME' => path.realpath.to_s,
        'RELATIVE_FILENAME' => File.join('.', path)
      }

      ENV['FILEPATH'] = path.realpath.to_s if event != :delete

      if options[:restart]
        child_pid =
          if child_pid.nil?
            Process.spawn(env, cmd)
          else
            restart(child_pid, env, cmd)
          end
      else
        begin
          Process.spawn(env, cmd)
          Process.wait
        rescue SystemExit, Interrupt
          exit(0)
        end
      end

    else
      case event
      when :changed
        print 'file updated'
      when :delete
        print 'file deleted'
      when :new
        print 'new file'
      else
        print event.to_s
      end
      puts ": #{filename}"
    end
  end
rescue SystemExit, Interrupt
  fw.finalize
end
